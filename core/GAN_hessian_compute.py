"""
Higher level API for GAN hessian compute, esp. `hessian_compute` 

Binxu Wang
Sep,2020
"""
import numpy as np
from time import time
# from hessian_eigenthings.lanczos import lanczos
from .lanczos_generalized import lanczos
from .GAN_hvp_operator import GANForwardMetricHVPOperator, GANHVPOperator, get_full_hessian

def hessian_compute(G, feat, ImDist, hessian_method="BackwardIter", cutoff=None, preprocess=lambda img: img, EPS=1E-3, device="cuda", ):
    """Higher level API for GAN hessian compute
    For iterative methods "BackwardIter" "ForwardIter", it 
        1. Defines the HVP operator as in GAN_hvp_operator
        2. call lanczos to solve the eigen problem iteratively. Get eigvals, eigvects
        3. Reconstruct \hat H with eigvals, eigvects. 

    For exact method "BP", it
        1. Double backprop to compute Hessian H. 
        2. Do eigen factorization. Get eigvals, eigvects

    Parameters:
        G: GAN, usually wrapped up by a custom class. Equipped with a `visualize` function that takes a torch vector and
           output a torch image, see `GAN_utils` 
        feat: a latent code as input to the GAN.
        ImDist: the image distance function. Support dsim = ImDist(img1, img2). takes in 2 torch images and output a
           scalar distance. Pass gradient.
        hessian_method: Currently, "BP" "ForwardIter" "BackwardIter" are supported
        preprocess: or post processing is the operation on the image generated by GAN. Default to be an identity map.
            e.g. `lambda img: F.interpolate(img, (256, 256), mode='bilinear', align_corners=True)` 
        cutoff: For iterative methods, ("ForwardIter" "BackwardIter") this specify how many eigenvectors it's going to
            compute.
    Returns:
        eigvals: Eigenvalues, numpy array of [n, ]
        eigvects: 
        H: Hessian matrix. numpy array of [n, n], 
    """
    T0 = time()
    if cutoff is None: cutoff = feat.numel() // 2 - 1
    if 'to' in dir(ImDist): ImDist.to(device)
    if hessian_method == "BackwardIter":
        metricHVP = GANHVPOperator(G, feat, ImDist, preprocess=preprocess)
        eigvals, eigvects = lanczos(metricHVP, num_eigenthings=cutoff, use_gpu=True)  # takes 113 sec on K20x cluster,
        eigvects = eigvects.T  # note the output shape from lanczos is different from that of linalg.eigh, row is eigvec
        H = eigvects @ np.diag(eigvals) @ eigvects.T
    elif hessian_method == "ForwardIter":
        metricHVP = GANForwardMetricHVPOperator(G, feat, ImDist, preprocess=preprocess, EPS=EPS)  # 1E-3,)
        eigvals, eigvects = lanczos(metricHVP, num_eigenthings=cutoff, use_gpu=True, max_steps=200, tol=1e-6, )
        eigvects = eigvects.T
        H = eigvects @ np.diag(eigvals) @ eigvects.T
    elif hessian_method == "BP":  
        ref_vect = feat.detach().clone().float().to(device)
        mov_vect = ref_vect.float().detach().clone().requires_grad_(True)
        imgs1 = G.visualize(ref_vect)
        imgs2 = G.visualize(mov_vect)
        dsim = ImDist(preprocess(imgs1), preprocess(imgs2))
        H = get_full_hessian(dsim, mov_vect)  
        eigvals, eigvects = np.linalg.eigh(H)
    else:
        raise NotImplementedError
    print("Hessian computed with %s in %.2f sec" % (hessian_method, time() - T0))
    return eigvals, eigvects, H

def layer_hessian_compute(feat, net, ):
    pass
#%%
if __name__ == "__main__":
    #%% Demo
    from time import time
    import torch
    import lpips
    from GAN_utils import loadBigGAN, BigGAN_wrapper
    ImDist = lpips.LPIPS(model='net-lin', net='squeeze', use_gpu=1, gpu_ids=[0])
    from GAN_utils import loadBigGAN, BigGAN_wrapper
    BGAN = loadBigGAN()
    BGAN.cuda().eval()
    G = BigGAN_wrapper(BGAN)
    feat = 0.05 * torch.randn(1, 256).detach().clone().cuda()
    EPS = 1E-2
    T0 = time()
    eva_BI, evc_BI, H_BI = hessian_compute(G, feat, ImDist, hessian_method="BackwardIter")
    print("%.2f sec" % (time() - T0))  # 70.57 sec
    T0 = time()
    eva_FI, evc_FI, H_FI = hessian_compute(G, feat, ImDist, hessian_method="ForwardIter")
    print("%.2f sec" % (time() - T0))  # 67.02 sec
    T0 = time()
    eva_BP, evc_BP, H_BP = hessian_compute(G, feat, ImDist, hessian_method="BP")
    print("%.2f sec" % (time() - T0))  # 69.4 sec